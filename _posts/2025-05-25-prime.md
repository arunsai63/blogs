---
title: "ğŸš€ From Hours to Milliseconds: A Journey Through Code Optimization"
date: 2025-05-25
tags:
  - Python
  - Optimization
  - Performance
  - Algorithms
---

# ğŸš€ From Hours to Milliseconds: A Journey Through Code Optimization

Every developer writes a brute-force solution at some point â€” often just to get things working.  
But what if that **quick-and-dirty function** was silently tanking your performance?

In this post, we'll explore how to go from **slow and clunky** to **blazing fast**, using one deceptively simple problem: **checking if a number is prime**.

---

## ğŸ§© The Problem: `is_prime(n)`

We want a function that checks if a number is prime. Easy to describe. Easy to get wrong.

Letâ€™s start with a naive solution and work our way up.

---

## ğŸŒ Step 1: Naive Brute Force (Please Donâ€™t)

```python
def is_prime(n: int):
    factors_count = 0
    for i in range(1, n + 1):
        if n % i == 0:
            factors_count += 1
    return factors_count == 2

ğŸ”» Whatâ€™s wrong here?
It checks every number from 1 to n.
Try this with 10,000 numbers? Pack a lunch.

â¸»

âš™ï¸ Step 3: Basic Divisibility

def is_prime(n: int):
    if n <= 1:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

âœ… Exits early on the first divisor â€” a decent start, but still O(n).

â¸»

âš¡ Step 4: Skip Even Numbers

def is_prime(n: int):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, n, 2):
        if n % i == 0:
            return False
    return True

ğŸ§  Insight: Half the numbers are even. Skip them.

Result: ~2Ã— faster in practice.

â¸»

ğŸ§® Step 5: Square Root Optimization

import math

def is_prime(n: int):
    if n <= 1:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True

ğŸƒâ€â™‚ï¸ Loop now runs âˆšn times, not n. Thatâ€™s a massive upgrade.

â¸»

ğŸ§  Step 6: The 6k Â± 1 Trick

def is_prime(n: int):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

ğŸ’¡ Why this works: All primes > 3 are of the form 6k Â± 1.
Fewer checks = faster results.

â¸»

ğŸ§ª Benchmark Results

We ran each function on 10,000 numbers (from 100,000 to 110,000):

Version	Relative Time (best = 1.0)
Step 3: Basic Loop	~2.24Ã— slower
Step 4: Skip Even	~1.00Ã—
Step 5: âˆšn Optimization	~0.01Ã— (fastest)
Step 6: 6k Â± 1 Rule	~0.01Ã— (fastest)

âš ï¸ Step 1 took too long to even finish.

â¸»

ğŸ§  Optimization Takeaways

This wasnâ€™t just about prime numbers. Itâ€™s a mini-lesson in performance thinking:
	â€¢	âœ… Exit early when possible
	â€¢	ğŸ§¹ Cut unnecessary work (e.g., skip evens, stop at âˆšn)
	â€¢	ğŸ§  Use mathematical structure where it exists
	â€¢	â±ï¸ Always measure â€” not guess

â¸»

ğŸ§µ Final Thoughts

You donâ€™t need to over-optimize everything.

But knowing how and when to optimize makes you a better developer â€” and a faster one, too.

The humble is_prime() function is a beautiful example:
	â€¢	Start naive
	â€¢	Refine the logic
	â€¢	Eliminate waste
	â€¢	Apply theory

â¸»

ğŸ” Try This Next

Apply the same optimization mindset to:
	â€¢	Sorting algorithms
	â€¢	String search
	â€¢	Matrix multiplications
	â€¢	I/O-heavy tasks

Thanks for reading â€” and happy optimizing! ğŸš€

